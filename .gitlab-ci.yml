stages:
  - test
  - lint
  # - build
  # - deploy

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
      when: never
    - if: $CI_COMMIT_BRANCH

variables:
  PROD_BRANCH: "main"
  DEV_BRANCH: "develop"

# .before_tpl:
#   before_script:
#     - |
#       if [ ! $(kubectl get ns ${NS} -o name) ]; then
#         kubectl create ns ${NS};
#         kubectl create secret docker-registry regcred --docker-server="https://${CI_REGISTRY}" \
#         --docker-username=${CI_DEPLOY_USER} --docker-password=${CI_DEPLOY_PASSWORD} -n ${NS};
#       fi

.yarn_cache_tpl:
  before_script:
    - echo 'yarn-offline-mirror ".yarn-cache/"' >> .yarnrc
    - echo 'yarn-offline-mirror-pruning true' >> .yarnrc
    - yarn install --frozen-lockfile --no-progress
  cache:
    key:
      files:
        - yarn.lock
    paths:
      - .yarn-cache/

.kaniko-build:
  variables:
    # Additional options for Kaniko executor.
    # For more details see https://github.com/GoogleContainerTools/kaniko/blob/master/README.md#additional-flags
    KANIKO_ARGS: "--label ci.branch=${CI_COMMIT_BRANCH} --label ci.commit=${CI_COMMIT_SHA} --cache-copy-layers --cache=true"
    KANIKO_BUILD_CONTEXT: $CI_PROJECT_DIR
  stage: build
  image:
    # For latest releases see https://github.com/GoogleContainerTools/kaniko/releases
    # Only debug/*-debug versions of the Kaniko image are known to work within Gitlab CI
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  script:
    - |
      if [ -z ${IMAGE_TAG+x} ]; then
        if [ "$CI_COMMIT_REF_NAME" = $PROD_BRANCH ]; then
          if [ -n "$CI_COMMIT_TAG" ];then
            NOSLASH=$(echo "$CI_COMMIT_TAG" | tr -s / - )
            SANITIZED="${NOSLASH//[^a-zA-Z0-9.-]/}"
            TAG_FOR_DEFAULT_BRANCHE="$SANITIZED"
            KANIKO_ARGS="${KANIKO_ARGS} --label ci.tag=${TAG_FOR_DEFAULT_BRANCHE} --destination ${TAG_FOR_DEFAULT_BRANCHE}"
            VERSION="latest"
          fi
        elif [ -n "$CI_COMMIT_TAG" ];then
          NOSLASH=$(echo "$CI_COMMIT_TAG" | tr -s / - )
          SANITIZED="${NOSLASH//[^a-zA-Z0-9.-]/}"
          VERSION="$SANITIZED"
          KANIKO_ARGS="${KANIKO_ARGS} --label ci.tag=${VERSION}"
        else \
          NOSLASH=$(echo "$CI_COMMIT_REF_NAME" | tr -s / - )
          SANITIZED="${NOSLASH//[^a-zA-Z0-9-]/}"
          VERSION="branch-$SANITIZED-${CI_COMMIT_SHORT_SHA}-${CI_PIPELINE_ID}"
        fi
        if [ -n "$BUILD_TYPE" ]; then
          if [ "$BUILD_TYPE" = "develop" ]; then
            VERSION="${VERSION}-dev"
          fi
        fi
          
        export IMAGE_TAG=$CI_REGISTRY_IMAGE:$VERSION
      fi
    - echo $IMAGE_TAG
    - mkdir -p /kaniko/.docker
    # Write credentials to access Gitlab Container Registry within the runner/ci
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"auth\":\"$(echo -n
      ${CI_REGISTRY_USER}:${CI_REGISTRY_PASSWORD} |
      base64 | tr -d '\n')\"}}}" > /kaniko/.docker/config.json
    - cat /kaniko/.docker/config.json
    # Build and push the container. To disable push add --no-push
    # Both Dockerfile and Containerfile are supported. For retrocompatibility, if both files are present, Dockerfile will be used.
    - |
      if [ -z "$DOCKERFILE_PATH" ]; then
        if [ -f "$KANIKO_BUILD_CONTEXT/Dockerfile" ]; then
          DOCKERFILE_PATH="$KANIKO_BUILD_CONTEXT/Dockerfile"
        elif [ -n "$CONTAINERFILE_PATH" ]; then
          DOCKERFILE_PATH="$CONTAINERFILE_PATH"
        elif [ -f "$KANIKO_BUILD_CONTEXT/Containerfile" ]; then
          DOCKERFILE_PATH="$KANIKO_BUILD_CONTEXT/Containerfile"
        else \
          echo "No suitable configuration for the build context have been found. Please check your configuration."
          exit 1
        fi
      fi
    - echo $DOCKERFILE_PATH
    - /kaniko/executor --context $KANIKO_BUILD_CONTEXT --dockerfile $DOCKERFILE_PATH --destination $IMAGE_TAG $KANIKO_ARGS
  # Run this job in a branch/tag where a Containerfile/Dockerfile exists
  rules:
    - exists:
        - Containerfile
        - Dockerfile
    # custom Containerfile/Dockerfile path
    # If both variables are set, DOCKERFILE_PATH will be used
    - if: $DOCKERFILE_PATH
    - if: $CONTAINERFILE_PATH
    # custom build context without an explicit Dockerfile path
    - if: $KANIKO_BUILD_CONTEXT != $CI_PROJECT_DIR

unit-test-job:
  image:
    name: node:latest
  stage: test
  script:
    - yarn run test:unit --ci
  extends: .yarn_cache_tpl
  tags:
    - test-k8s
  rules:
    - if: "$CI_COMMIT_BRANCH"
  artifacts:
    when: always
    expire_in: "3 days"
    paths:
      - reports/junit.xml
    reports:
      junit: reports/junit.xml

cov-test-job:
  image:
    name: node:latest
  stage: test
  script:
    - yarn run test:cov --ci --coverageDirectory=coverage
  extends: .yarn_cache_tpl
  tags:
    - test-k8s
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: always
  artifacts:
    when: always
    expire_in: "3 days"
    paths:
      - reports/junit.xml
      - coverage/
    reports:
      junit: reports/junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml

lint-test-job:
  image:
    name: node:latest
  stage: lint
  variables:
    ESLINT_CODE_QUALITY_REPORT: gl-codequality.json
  script:
    - yarn run lint --format eslint-formatter-multiple
  extends: .yarn_cache_tpl
  tags:
    - test-k8s
  rules:
    - if: "$CI_COMMIT_BRANCH"
      when: always
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: always
  artifacts:
    when: always
    expire_in: "3 days"
    paths:
      - gl-codequality.json
      - reports/eslint-junit-report.xml
    reports:
      codequality: gl-codequality.json
      # junit: reports/eslint-junit-report.xml

.d_kaniko-build:
  stage: build
  extends: .kaniko-build
  variables:
    DOCKERFILE_PATH: "docker/Dockerfile.Prod"
  tags:
    - local-k8s

.deploy-job: # This job runs in the deploy stage.
  stage: deploy # It only runs when *both* jobs in the test stage complete successfully.
  environment: production
  script:
    - echo "Deploying application..."
    - echo "Application successfully deployed."
  tags:
    - local-k8s
